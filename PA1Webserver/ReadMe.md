#Programming Assignment 1#

**Objective** is to create a HTTP-based web server that handles various requests from users.

##Introduction##

This is a program of a server which contains 4 parts:

- Main Function
- Echo Function
- Error Handling Function
- Errexit Function

###Main Idea of each function###

1. **Main Function**: It contains the process of building a server to receive requests from client and send corresponding responses. At first, it defines some necessary structures using getaddrinfo() to build up a socket. Then we use values of getaddrinfo to feed to socket and bind a port to our socket. The next step is to call listen() and accept() to wait for incoming connections and accept them. Accept() returns a new file descriptor to process the current connection while our original file descriptor still listening to other connections in the queue. These steps above form a basic socket. Here we use fork() to make a server being able to handle multiple clients by creating child process. On the basis of this server, we use poll to set a 10s timer used for waiting incomming requests.
2. **Echo Function**: Inside the Echo Function, we do things like reading request from client, reading files and sending header information back to the client. The content types are from ws.conf and the url is from the request.
3. **Error Handling Function**: Inside this function, we listed some cases of error which could happen during executing the echo function, including 400 bad request, 404 not found, 501 not implemented and 500 internal server error.
4. **Errexit Function**: This function is the error of the program itsself. When we failed to read the request normally, it will be called and exit.

## Strategy to Realize Each Requirement##
1. **Showing the Webpage:** The first step is to receive requests from the client. The request consists three parts: method, url and version.After checking whether they are valid, we store them into a buffer. Then we get the request url and check whether the format is supported by our server. We get the content type, the document root from information of ws.conf. Then we write the header information back to the file descriptor and write the files as well. To show this webpage in our browser, we need to run the code, open the browser, type "localhost:8097" and the files will be sent to the client to show the webpage.
2. **Threading:** Threading means the server can handle multipule requests. When the client receive a webpage embedded pictures, it will send multiple requests to the server, such as asking the server to send pictures with different formats. the server should be able to respond to them before the file descriptor is closed. To test this we can do two things: one is to open the webpage, click each link of the picture to see whether the client's request to show them are processed by the server. We can also open many tabs samultaneously to see if they contain everything. Also we can print out the header information, each request will coming up in the terminal one by one, and thus justify our server is able to handle multiple requests. This is because we use fork() to create a child process to handle a current request, and the parent process keeps listening incoming requests.
3. **Pipelining:**To to this we need to implement a timer in fork(). In my program, poll() is my timer. We construct a structure which contains a file descriptor and bitmap of events. By feeding this structure, numbers of sockets(here we only have one), and the length of waiting time, poll() will give us a return value. If the value is -1, it means poll failed, if the value equals to 0, it means no data is transmitted, the connection will close after 10s. To test this, we first open the server in one terminal, in another terminal we type "telnet localhost 8097", and just wait. Then we will see the connection close in the second terminal and we can see the information we print coming up in the first terminal "Timeout occurred!  No data after 10 seconds.". We can also test this by typing the code provided in the pdf of this assignment, and it will show the content we expected below.
4. **Error Handling:** To justify the 400 bad request invalid method, we can type some other words like "pET" instead of "GET" in another terminal as the request method, the connection will closed. Or we can change the method in the code after reading from the file descriptor, if it isn't the correct one, the error message will shown on the screen. Thus we can also test invalid version, invalid url in the same way. Among them, invalid url mat contains many cases, here we only test two scenarios, the character ',' or '*' is not allowed in a correct url. To justify 404 not found, we can open the webpage, click a link of a picture, and change the name of that picture and hit enter. The waring message will shown. To justify the 501 not implemented, we just need to make the pointer of the file points to somewhere else. Run the code, open the webpage, the wrong message will shown. Actually, I am not sure if I understand the 501 internal server error exactly, it result from some server problem of the progam or the server, like the server fails to work, the error happens during the process of building the socket. If so, I print these warning messages in the main function instead of call the error handling function because I'm not sure.
5. **Configuration File:** I read the content type from this file and make a structure. First I search the 1st line of the content type, and read the file line by line. For each line I search for the space between extensions and content types. I compare the extensions with the request, and take corresponding content type. As for the document root I use similar method, first I search the key word Document root, take the part after the space, take the root between the double quote, and bind this root with differnt url that client requested.